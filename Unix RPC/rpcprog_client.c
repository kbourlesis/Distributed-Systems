/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpcprog.h"
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>

#define PORT 43862

struct parameters{

  int client, id, *available_IDs;
  char *host;

};

pthread_mutex_t mutex;

int str2int_array(char *data, send_data *my_data){

  char *num = NULL;
  int arr_size = 0;

	my_data->Y.Y_val = (int *)malloc(10 * sizeof(int));

  num = strtok(data, "\n");

  while (num != NULL) {

    num = strtok(NULL, "\n");

    if (num != NULL)
      my_data->Y.Y_val[arr_size++] = atoi(num);

    if (arr_size % 10 == 0) {
      //printf("Reallocating int array\n");
      if((my_data->Y.Y_val = (int *)realloc(my_data->Y.Y_val, ((arr_size + 10) * sizeof(int)))) == NULL){
				printf("Realloc error\n");
				exit(0);
			}
    }

  }

  //printf("arr_size: %d\n", arr_size);
  my_data->Y.Y_len = arr_size;

  /*for (size_t i = 0; i < arr_size; i++) {
    if (i == 0)
      printf("Vector[ ");

    printf("%d ",my_data->Y.Y_val[i]);

    if (i+1 == arr_size)
      printf("]\n");
  }*/

  return arr_size;
}

void avg_prog_1(char *host, char *data, int client){

	CLIENT *clnt;
	double  *result_1;
	send_data  avg_1_arg;

  #ifndef	DEBUG
  	clnt = clnt_create (host, AVG_PROG, AVG_VERS, "udp");
  	if (clnt == NULL) {
  		clnt_pcreateerror (host);
  		exit (1);
  	}
  #endif	/* DEBUG */

  str2int_array(data, &avg_1_arg);

	result_1 = avg_1(&avg_1_arg, clnt);
	if (result_1 == (double *) NULL) {
		clnt_perror (clnt, "call failed");
	}else{
		//printf("AVG: %.2lf\n", *result_1);

    send(client, result_1, sizeof(double), 0);

    free(avg_1_arg.Y.Y_val);
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

}


void min_max_prog_1(char *host, char *data, int client){

	CLIENT *clnt;
	receive_data  *result_1;
	send_data  min_max_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, MIN_MAX_PROG, MIN_MAX_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	str2int_array(data, &min_max_1_arg);

	result_1 = min_max_1(&min_max_1_arg, clnt);
	if (result_1 == (receive_data *) NULL) {
		clnt_perror (clnt, "call failed");
	}else{
		/*for (int i = 0; i < 2; i++) {
			if (i == 0) {
				printf("min max[ %d", result_1->int_arr.int_arr_val[i]);
			}else
				printf(" %d ]\n", result_1->int_arr.int_arr_val[i]);
		}*/

    send(client, result_1->int_arr.int_arr_val, (2 * sizeof(int)), 0);

    free(min_max_1_arg.Y.Y_val);
	}


#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

}


void mul_prog_1(char *host, char *data, char *multiplier,int client){

	CLIENT *clnt;
	receive_data  *result_1;
	send_data  mul_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, MUL_PROG, MUL_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

  int int_arr_size = 0;

  mul_1_arg.a = atof(multiplier);
  int_arr_size = str2int_array(data, &mul_1_arg);

	result_1 = mul_1(&mul_1_arg, clnt);
	if (result_1 == (receive_data *) NULL) {
		clnt_perror (clnt, "call failed");
	}else{
    /*for (size_t i = 0; i < int_arr_size; i++) {

  		if (i == 0) {
  			printf("Vector[ %0.2lf ", result_1->double_arr.double_arr_val[i]);
  		}else if (i+1 == int_arr_size) {
  			printf("%0.2lf ]\n",result_1->double_arr.double_arr_val[i]);
  		}else
  			printf("%0.2lf ",result_1->double_arr.double_arr_val[i]);

  		if (int_arr_size == 1) {
  			printf("]\n");
  		}
  	}*/

    send(client, &int_arr_size, sizeof(int), 0);
    send(client, result_1->double_arr.double_arr_val, int_arr_size * sizeof(double), 0);

    free(mul_1_arg.Y.Y_val);
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

}

void *proc_call(void *args){

  char *Data, *multiplier;
  int client_status, id_pos, thrd_id = 0, clnt_fd, data_arr_size = 0;

  struct parameters *parameter = ((struct parameters*)args);

  for (int i = 0; i < 10; i++) {
    if (parameter->available_IDs[i] != 0) {
      thrd_id = parameter->available_IDs[i];
      parameter->available_IDs[i] = 0;
      break;
    }
  }

  if (thrd_id == 0) {
    thrd_id = parameter->id;
  }

  id_pos = parameter->id;

  clnt_fd = parameter->client;

  multiplier = (char *)malloc(10);
  memset(multiplier, 0, 10);

  printf("\n==> Client %d connected <==\n", thrd_id);


  while (1) {

    recv(clnt_fd, &data_arr_size, sizeof(int), 0);

    Data = (char *)malloc(data_arr_size);
    memset(Data, 0, data_arr_size);

    client_status = recv(clnt_fd, Data, data_arr_size, 0);
    Data[data_arr_size] = 0;

    if ((strcmp(Data,"exit") == 0) || (client_status == 0)){
      free(multiplier);
      free(Data);
      break;
    }

	  if (Data[0] == '1'){
      printf("\n* Client %d called average function\n", thrd_id);
		  avg_prog_1 (parameter->host, Data, clnt_fd);
    }

	  if (Data[0] == '2'){
      printf("\n* Client %d called min/max function\n", thrd_id);
		  min_max_prog_1 (parameter->host, Data, clnt_fd);
    }

	  if (Data[0] == '3'){
      printf("\n* Client %d called multiplication function\n", thrd_id);
      recv(clnt_fd, multiplier, 10, 0);
		  mul_prog_1 (parameter->host, Data, multiplier, clnt_fd);
      memset(multiplier, 0, 10);

    }

    free(Data);

  }

  pthread_mutex_lock(&mutex);

    parameter->id -= 1;
    parameter->available_IDs[id_pos-1] = thrd_id;
    /*printf("id: %d\n",parameter->id );
    for (int i = 0; i < 10; i++) {
      printf("available_id[%d]: %d\n",i,parameter->available_IDs[i] );
    }*/

  pthread_mutex_unlock(&mutex);

  printf("\n<~~ Client %d disconnected ~~>\n", thrd_id);

  close(clnt_fd);

  pthread_exit(NULL);
}

int main (int argc, char *argv[]){

  int connected_client, socket_fd, opt = 1, client_len;
  pthread_t thread;

  struct sockaddr_in client_info;

  pthread_mutex_init(&mutex, NULL);

	if (argc != 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (EXIT_FAILURE);
	}

  if ((socket_fd = socket(AF_INET,SOCK_STREAM,0)) == -1) {
    perror("socket");
    exit(EXIT_FAILURE);
  }

  setsockopt(socket_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(int));

  bzero(&client_info, sizeof(client_info));

  client_info.sin_family = AF_INET;
  client_info.sin_port = htons(PORT);
  client_info.sin_addr.s_addr = INADDR_ANY;

  client_len = sizeof(client_info);

  if (bind(socket_fd, (struct sockaddr *)&client_info, sizeof(client_info)) < 0){
       perror("Bind failed");
       exit(EXIT_FAILURE);
   }

  if (listen(socket_fd, 3) < 0){
        perror("listen");
        exit(EXIT_FAILURE);
  }

  struct parameters func_parameters;
  func_parameters.id = 0;
  func_parameters.available_IDs = (int *)malloc(10 * sizeof(int));
  memset(func_parameters.available_IDs, 0, 10);

  printf("Waiting for clients...\n");

  while (1) {

    if ((connected_client = accept(socket_fd, (struct sockaddr *)&client_info, (socklen_t*)&client_info)) < 0){
          perror("accept");
          exit(EXIT_FAILURE);
      }

    func_parameters.host = argv[1];
    func_parameters.client = connected_client;
    func_parameters.id++;

    if(pthread_create(&thread, NULL, proc_call,(void *)&func_parameters) != 0){
      printf("Failed to create the thread.\n");
      exit(0);
    }

  }

  //never reached!
  exit(0);
}
